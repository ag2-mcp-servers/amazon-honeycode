# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T11:48:50+00:00

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional

from pydantic import BaseModel, ConfigDict, Field, RootModel, SecretStr, conint, constr


class AccessDeniedException(RootModel[Any]):
    root: Any


class AutomationExecutionException(RootModel[Any]):
    root: Any


class AutomationExecutionTimeoutException(RootModel[Any]):
    root: Any


class AwsUserArn(RootModel[constr(min_length=20, max_length=2048)]):
    root: constr(min_length=20, max_length=2048)


class BatchErrorMessage(RootModel[constr(pattern=r'^(?!\s*$).+')]):
    model_config = ConfigDict(
        regex_engine="python-re",
    )
    root: constr(pattern=r'^(?!\s*$).+')


class BatchItemId(
    RootModel[constr(pattern=r'^(?!\s*$).+', min_length=1, max_length=64)]
):
    model_config = ConfigDict(
        regex_engine="python-re",
    )
    root: constr(pattern=r'^(?!\s*$).+', min_length=1, max_length=64)


class ClientRequestToken(
    RootModel[constr(pattern=r'^(?!\s*$).+', min_length=32, max_length=64)]
):
    model_config = ConfigDict(
        regex_engine="python-re",
    )
    root: constr(pattern=r'^(?!\s*$).+', min_length=32, max_length=64)


class DelimitedTextDelimiter(
    RootModel[
        constr(
            pattern=r'^[^\n\r\x00\x08\x0B\x0C\x0E\x1F]?$', min_length=1, max_length=1
        )
    ]
):
    root: constr(
        pattern=r'^[^\n\r\x00\x08\x0B\x0C\x0E\x1F]?$', min_length=1, max_length=1
    )


class DescribeTableDataImportJobRequest(BaseModel):
    pass


class Email(RootModel[SecretStr]):
    root: SecretStr


class ErrorCode(Enum):
    ACCESS_DENIED = 'ACCESS_DENIED'
    INVALID_URL_ERROR = 'INVALID_URL_ERROR'
    INVALID_IMPORT_OPTIONS_ERROR = 'INVALID_IMPORT_OPTIONS_ERROR'
    INVALID_TABLE_ID_ERROR = 'INVALID_TABLE_ID_ERROR'
    INVALID_TABLE_COLUMN_ID_ERROR = 'INVALID_TABLE_COLUMN_ID_ERROR'
    TABLE_NOT_FOUND_ERROR = 'TABLE_NOT_FOUND_ERROR'
    FILE_EMPTY_ERROR = 'FILE_EMPTY_ERROR'
    INVALID_FILE_TYPE_ERROR = 'INVALID_FILE_TYPE_ERROR'
    FILE_PARSING_ERROR = 'FILE_PARSING_ERROR'
    FILE_SIZE_LIMIT_ERROR = 'FILE_SIZE_LIMIT_ERROR'
    FILE_NOT_FOUND_ERROR = 'FILE_NOT_FOUND_ERROR'
    UNKNOWN_ERROR = 'UNKNOWN_ERROR'
    RESOURCE_NOT_FOUND_ERROR = 'RESOURCE_NOT_FOUND_ERROR'
    SYSTEM_LIMIT_ERROR = 'SYSTEM_LIMIT_ERROR'


class Fact(RootModel[SecretStr]):
    root: SecretStr


class FactList(RootModel[List[Fact]]):
    root: List[Fact] = Field(..., max_length=220, min_length=0)


class FailedBatchItem(BaseModel):
    errorMessage: BatchErrorMessage
    id: BatchItemId


class FailedBatchItems(RootModel[List[FailedBatchItem]]):
    root: List[FailedBatchItem] = Field(..., max_length=100, min_length=0)


class Format(Enum):
    AUTO = 'AUTO'
    NUMBER = 'NUMBER'
    CURRENCY = 'CURRENCY'
    DATE = 'DATE'
    TIME = 'TIME'
    DATE_TIME = 'DATE_TIME'
    PERCENTAGE = 'PERCENTAGE'
    TEXT = 'TEXT'
    ACCOUNTING = 'ACCOUNTING'
    CONTACT = 'CONTACT'
    ROWLINK = 'ROWLINK'
    ROWSET = 'ROWSET'


class FormattedValue(
    RootModel[constr(pattern=r'[\s\S]*', min_length=0, max_length=8192)]
):
    root: constr(pattern=r'[\s\S]*', min_length=0, max_length=8192)


class FormattedValuesList(RootModel[List[FormattedValue]]):
    root: List[FormattedValue] = Field(..., max_length=220, min_length=0)


class Formula(RootModel[SecretStr]):
    root: SecretStr


class HasHeaderRow(RootModel[bool]):
    root: bool


class IgnoreEmptyRows(RootModel[bool]):
    root: bool


class ImportDataCharacterEncoding(Enum):
    UTF_8 = 'UTF-8'
    US_ASCII = 'US-ASCII'
    ISO_8859_1 = 'ISO-8859-1'
    UTF_16BE = 'UTF-16BE'
    UTF_16LE = 'UTF-16LE'
    UTF_16 = 'UTF-16'


class ImportJobSubmitter(BaseModel):
    email: Optional[Email] = None
    userArn: Optional[AwsUserArn] = None


class ImportSourceDataFormat(Enum):
    DELIMITED_TEXT = 'DELIMITED_TEXT'


class InternalServerException(RootModel[Any]):
    root: Any


class JobId(
    RootModel[
        constr(
            pattern=r'^[^\n\r\x00\x08\x0B\x0C\x0E\x1F]*$', min_length=1, max_length=100
        )
    ]
):
    root: constr(
        pattern=r'^[^\n\r\x00\x08\x0B\x0C\x0E\x1F]*$', min_length=1, max_length=100
    )


class ListTableColumnsRequest(BaseModel):
    pass


class ListTablesRequest(BaseModel):
    pass


class ListTagsForResourceRequest(BaseModel):
    pass


class MaxResults(RootModel[conint(ge=1, le=100)]):
    root: conint(ge=1, le=100)


class Name(RootModel[SecretStr]):
    root: SecretStr


class PaginationToken(
    RootModel[constr(pattern=r'^(?!\s*$).+', min_length=1, max_length=1024)]
):
    model_config = ConfigDict(
        regex_engine="python-re",
    )
    root: constr(pattern=r'^(?!\s*$).+', min_length=1, max_length=1024)


class RawValue(RootModel[constr(pattern=r'[\s\S]*', min_length=0, max_length=32767)]):
    root: constr(pattern=r'[\s\S]*', min_length=0, max_length=32767)


class RequestTimeoutException(RootModel[Any]):
    root: Any


class ResourceArn(
    RootModel[
        constr(
            pattern=r'^arn:aws:honeycode:.+:[0-9]{12}:.+:.+$',
            min_length=1,
            max_length=256,
        )
    ]
):
    root: constr(
        pattern=r'^arn:aws:honeycode:.+:[0-9]{12}:.+:.+$', min_length=1, max_length=256
    )


class ResourceId(
    RootModel[
        constr(
            pattern=r'[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}',
            min_length=36,
            max_length=36,
        )
    ]
):
    root: constr(
        pattern=r'[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}',
        min_length=36,
        max_length=36,
    )


class ResourceIds(RootModel[List[ResourceId]]):
    root: List[ResourceId] = Field(..., max_length=100, min_length=1)


class ResourceNotFoundException(RootModel[Any]):
    root: Any


class RowId(
    RootModel[
        constr(
            pattern=r'row:[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\/[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}',
            min_length=77,
            max_length=77,
        )
    ]
):
    root: constr(
        pattern=r'row:[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\/[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}',
        min_length=77,
        max_length=77,
    )


class RowIdList(RootModel[List[RowId]]):
    root: List[RowId] = Field(..., max_length=100, min_length=1)


class SecureURL(RootModel[SecretStr]):
    root: SecretStr


class ServiceQuotaExceededException(RootModel[Any]):
    root: Any


class ServiceUnavailableException(RootModel[Any]):
    root: Any


class SourceDataColumnIndex(RootModel[conint(ge=1)]):
    root: conint(ge=1)


class SourceDataColumnProperties(BaseModel):
    columnIndex: Optional[SourceDataColumnIndex] = None


class TableColumnName(RootModel[str]):
    root: str


class TableDataImportJobMessage(RootModel[str]):
    root: str


class TableDataImportJobStatus(Enum):
    SUBMITTED = 'SUBMITTED'
    IN_PROGRESS = 'IN_PROGRESS'
    COMPLETED = 'COMPLETED'
    FAILED = 'FAILED'


class TableName(RootModel[str]):
    root: str


class TagKey(
    RootModel[
        constr(
            pattern=r'^[^\n\r\x00\x08\x0B\x0C\x0E\x1F]*$', min_length=1, max_length=100
        )
    ]
):
    root: constr(
        pattern=r'^[^\n\r\x00\x08\x0B\x0C\x0E\x1F]*$', min_length=1, max_length=100
    )


class TagKeysList(RootModel[List[TagKey]]):
    root: List[TagKey] = Field(..., description='A list of tag keys', max_length=100)


class TagResourceResult(BaseModel):
    pass


class TagValue(
    RootModel[
        constr(
            pattern=r'^[^\n\r\x00\x08\x0B\x0C\x0E\x1F]*$', min_length=1, max_length=100
        )
    ]
):
    root: constr(
        pattern=r'^[^\n\r\x00\x08\x0B\x0C\x0E\x1F]*$', min_length=1, max_length=100
    )


class TagsMap(RootModel[Optional[Dict[str, TagValue]]]):
    root: Optional[Dict[str, TagValue]] = None


class ThrottlingException(RootModel[Any]):
    root: Any


class TimestampInMillis(RootModel[datetime]):
    root: datetime


class UntagResourceRequest(BaseModel):
    pass


class UntagResourceResult(BaseModel):
    pass


class UpsertAction(Enum):
    UPDATED = 'UPDATED'
    APPENDED = 'APPENDED'


class UpsertRowsResult(BaseModel):
    rowIds: RowIdList
    upsertAction: UpsertAction


class UpsertRowsResultMap(RootModel[Optional[Dict[str, UpsertRowsResult]]]):
    root: Optional[Dict[str, UpsertRowsResult]] = None


class ValidationException(RootModel[Any]):
    root: Any


class VariableName(RootModel[SecretStr]):
    root: SecretStr


class VariableValue(BaseModel):
    rawValue: RawValue


class VariableValueMap(RootModel[Optional[Dict[str, VariableValue]]]):
    root: Optional[Dict[str, VariableValue]] = None


class WorkbookCursor(RootModel[int]):
    root: int


class ScreendataPostRequest(BaseModel):
    model_config = ConfigDict(
        regex_engine="python-re",
    )
    appId: constr(
        pattern=r'[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}',
        min_length=36,
        max_length=36,
    ) = Field(..., description='The ID of the app that contains the screen.')
    maxResults: Optional[conint(ge=1, le=100)] = Field(
        None,
        description="<p> The number of results to be returned on a single page. Specify a number between 1 and 100. The maximum value is 100. </p> <p> This parameter is optional. If you don't specify this parameter, the default page size is 100. </p>",
    )
    nextToken: Optional[
        constr(pattern=r'^(?!\s*$).+', min_length=1, max_length=1024)
    ] = Field(
        None,
        description='<p> This parameter is optional. If a nextToken is not specified, the API returns the first page of data. </p> <p> Pagination tokens expire after 1 hour. If you use a token that was returned more than an hour back, the API will throw ValidationException. </p>',
    )
    screenId: constr(
        pattern=r'[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}',
        min_length=36,
        max_length=36,
    ) = Field(..., description='The ID of the screen.')
    variables: Optional[Dict[str, VariableValue]] = Field(
        None,
        description=' Variables are optional and are needed only if the screen requires them to render correctly. Variables are specified as a map where the key is the name of the variable as defined on the screen. The value is an object which currently has only one property, rawValue, which holds the value of the variable to be passed to the screen. ',
    )
    workbookId: constr(
        pattern=r'[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}',
        min_length=36,
        max_length=36,
    ) = Field(..., description='The ID of the workbook that contains the screen.')


class TagsResourceArnPostRequest(BaseModel):
    tags: Dict[str, TagValue] = Field(
        ..., description='A string to string map representing tags'
    )


class TagKeys(RootModel[List[TagKey]]):
    root: List[TagKey] = Field(..., description='A list of tag keys', max_length=100)


class WorkbooksWorkbookIdAppsAppIdScreensScreenIdAutomationsAutomationIdPostRequest(
    BaseModel
):
    model_config = ConfigDict(
        regex_engine="python-re",
    )
    clientRequestToken: Optional[
        constr(pattern=r'^(?!\s*$).+', min_length=32, max_length=64)
    ] = Field(
        None,
        description='<p> The request token for performing the automation action. Request tokens help to identify duplicate requests. If a call times out or fails due to a transient error like a failed network connection, you can retry the call with the same request token. The service ensures that if the first call using that request token is successfully performed, the second call will return the response of the previous call rather than performing the action again. </p> <p> Note that request tokens are valid only for a few minutes. You cannot use request tokens to dedupe requests spanning hours or days. </p>',
    )
    rowId: Optional[
        constr(
            pattern=r'row:[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\/[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}',
            min_length=77,
            max_length=77,
        )
    ] = Field(
        None,
        description=' The row ID for the automation if the automation is defined inside a block with source or list. ',
    )
    variables: Optional[Dict[str, VariableValue]] = Field(
        None,
        description=' Variables are specified as a map where the key is the name of the variable as defined on the screen. The value is an object which currently has only one property, rawValue, which holds the value of the variable to be passed to the screen. Any variables defined in a screen are required to be passed in the call. ',
    )


class DataFormat(Enum):
    DELIMITED_TEXT = 'DELIMITED_TEXT'


class WorkbooksWorkbookIdTablesTableIdRowsBatchdeletePostRequest(BaseModel):
    model_config = ConfigDict(
        regex_engine="python-re",
    )
    clientRequestToken: Optional[
        constr(pattern=r'^(?!\s*$).+', min_length=32, max_length=64)
    ] = Field(
        None,
        description='<p> The request token for performing the delete action. Request tokens help to identify duplicate requests. If a call times out or fails due to a transient error like a failed network connection, you can retry the call with the same request token. The service ensures that if the first call using that request token is successfully performed, the second call will not perform the action again. </p> <p> Note that request tokens are valid only for a few minutes. You cannot use request tokens to dedupe requests spanning hours or days. </p>',
    )
    rowIds: List[RowId] = Field(
        ...,
        description='<p> The list of row ids to delete from the table. You need to specify at least one row id in this list. </p> <p> Note that if one of the row ids provided in the request does not exist in the table, then the request fails and no rows are deleted from the table. </p>',
        max_length=100,
        min_length=1,
    )


class WorkbooksWorkbookIdTablesTableIdRowsListPostRequest(BaseModel):
    model_config = ConfigDict(
        regex_engine="python-re",
    )
    maxResults: Optional[conint(ge=1, le=100)] = Field(
        None,
        description='The maximum number of rows to return in each page of the results.',
    )
    nextToken: Optional[
        constr(pattern=r'^(?!\s*$).+', min_length=1, max_length=1024)
    ] = Field(
        None,
        description='<p> This parameter is optional. If a nextToken is not specified, the API returns the first page of data. </p> <p> Pagination tokens expire after 1 hour. If you use a token that was returned more than an hour back, the API will throw ValidationException. </p>',
    )
    rowIds: Optional[List[RowId]] = Field(
        None,
        description=' This parameter is optional. If one or more row ids are specified in this list, then only the specified row ids are returned in the result. If no row ids are specified here, then all the rows in the table are returned. ',
        max_length=100,
        min_length=1,
    )


class FilterFormula(BaseModel):
    contextRowId: Optional[RowId] = None
    formula: Optional[Formula] = None


class WorkbooksWorkbookIdTablesTableIdRowsQueryPostRequest(BaseModel):
    model_config = ConfigDict(
        regex_engine="python-re",
    )
    filterFormula: FilterFormula = Field(
        ...,
        description=' An object that represents a filter formula along with the id of the context row under which the filter function needs to evaluate. ',
    )
    maxResults: Optional[conint(ge=1, le=100)] = Field(
        None,
        description='The maximum number of rows to return in each page of the results.',
    )
    nextToken: Optional[
        constr(pattern=r'^(?!\s*$).+', min_length=1, max_length=1024)
    ] = Field(
        None,
        description='<p> This parameter is optional. If a nextToken is not specified, the API returns the first page of data. </p> <p> Pagination tokens expire after 1 hour. If you use a token that was returned more than an hour back, the API will throw ValidationException. </p>',
    )


class BatchDeleteTableRowsRequest(BaseModel):
    clientRequestToken: Optional[ClientRequestToken] = None
    rowIds: RowIdList


class BatchDeleteTableRowsResult(BaseModel):
    failedBatchItems: Optional[FailedBatchItems] = None
    workbookCursor: WorkbookCursor


class BatchUpdateTableRowsResult(BaseModel):
    failedBatchItems: Optional[FailedBatchItems] = None
    workbookCursor: WorkbookCursor


class BatchUpsertTableRowsResult(BaseModel):
    failedBatchItems: Optional[FailedBatchItems] = None
    rows: UpsertRowsResultMap
    workbookCursor: WorkbookCursor


class Cell(BaseModel):
    format: Optional[Format] = None
    formattedValue: Optional[FormattedValue] = None
    formattedValues: Optional[FormattedValuesList] = None
    formula: Optional[Formula] = None
    rawValue: Optional[RawValue] = None


class CellInput(BaseModel):
    fact: Optional[Fact] = None
    facts: Optional[FactList] = None


class Cells(RootModel[List[Cell]]):
    root: List[Cell]


class ColumnMetadata(BaseModel):
    format: Format
    name: Name


class CreatedRowsMap(RootModel[Optional[Dict[str, RowId]]]):
    root: Optional[Dict[str, RowId]] = None


class DataItem(BaseModel):
    formattedValue: Optional[FormattedValue] = None
    overrideFormat: Optional[Format] = None
    rawValue: Optional[RawValue] = None


class DataItems(RootModel[List[DataItem]]):
    root: List[DataItem]


class DelimitedTextImportOptions(BaseModel):
    dataCharacterEncoding: Optional[ImportDataCharacterEncoding] = None
    delimiter: DelimitedTextDelimiter
    hasHeaderRow: Optional[HasHeaderRow] = None
    ignoreEmptyRows: Optional[IgnoreEmptyRows] = None


class Filter(BaseModel):
    contextRowId: Optional[RowId] = None
    formula: Formula


class GetScreenDataRequest(BaseModel):
    appId: ResourceId
    maxResults: Optional[MaxResults] = None
    nextToken: Optional[PaginationToken] = None
    screenId: ResourceId
    variables: Optional[VariableValueMap] = None
    workbookId: ResourceId


class ImportColumnMap(RootModel[Optional[Dict[str, SourceDataColumnProperties]]]):
    root: Optional[Dict[str, SourceDataColumnProperties]] = None


class ImportDataSourceConfig(BaseModel):
    dataSourceUrl: Optional[SecureURL] = None


class InvokeScreenAutomationRequest(BaseModel):
    clientRequestToken: Optional[ClientRequestToken] = None
    rowId: Optional[RowId] = None
    variables: Optional[VariableValueMap] = None


class InvokeScreenAutomationResult(BaseModel):
    workbookCursor: WorkbookCursor


class ListTableRowsRequest(BaseModel):
    maxResults: Optional[MaxResults] = None
    nextToken: Optional[PaginationToken] = None
    rowIds: Optional[RowIdList] = None


class ListTagsForResourceResult(BaseModel):
    tags: Optional[TagsMap] = None


class QueryTableRowsRequest(BaseModel):
    filterFormula: Filter
    maxResults: Optional[MaxResults] = None
    nextToken: Optional[PaginationToken] = None


class ResultHeader(RootModel[List[ColumnMetadata]]):
    root: List[ColumnMetadata]


class ResultRow(BaseModel):
    dataItems: DataItems
    rowId: Optional[RowId] = None


class ResultRows(RootModel[List[ResultRow]]):
    root: List[ResultRow]


class ResultSet(BaseModel):
    headers: ResultHeader
    rows: ResultRows


class ResultSetMap(RootModel[Optional[Dict[str, ResultSet]]]):
    root: Optional[Dict[str, ResultSet]] = None


class RowDataInput(RootModel[Optional[Dict[str, CellInput]]]):
    root: Optional[Dict[str, CellInput]] = None


class StartTableDataImportJobResult(BaseModel):
    jobId: JobId
    jobStatus: TableDataImportJobStatus


class Table(BaseModel):
    tableId: Optional[ResourceId] = None
    tableName: Optional[TableName] = None


class TableColumn(BaseModel):
    format: Optional[Format] = None
    tableColumnId: Optional[ResourceId] = None
    tableColumnName: Optional[TableColumnName] = None


class TableColumns(RootModel[List[TableColumn]]):
    root: List[TableColumn]


class TableRow(BaseModel):
    cells: Cells
    rowId: RowId


class TableRows(RootModel[List[TableRow]]):
    root: List[TableRow]


class Tables(RootModel[List[Table]]):
    root: List[Table]


class TagResourceRequest(BaseModel):
    tags: TagsMap


class UpdateRowData(BaseModel):
    cellsToUpdate: RowDataInput
    rowId: RowId


class UpdateRowDataList(RootModel[List[UpdateRowData]]):
    root: List[UpdateRowData] = Field(..., max_length=100, min_length=1)


class UpsertRowData(BaseModel):
    batchItemId: BatchItemId
    cellsToUpdate: RowDataInput
    filter: Filter


class UpsertRowDataList(RootModel[List[UpsertRowData]]):
    root: List[UpsertRowData]


class DataSource(BaseModel):
    dataSourceConfig: Optional[ImportDataSourceConfig] = None


class WorkbooksWorkbookIdTablesTableIdRowsBatchupdatePostRequest(BaseModel):
    model_config = ConfigDict(
        regex_engine="python-re",
    )
    clientRequestToken: Optional[
        constr(pattern=r'^(?!\s*$).+', min_length=32, max_length=64)
    ] = Field(
        None,
        description='<p> The request token for performing the update action. Request tokens help to identify duplicate requests. If a call times out or fails due to a transient error like a failed network connection, you can retry the call with the same request token. The service ensures that if the first call using that request token is successfully performed, the second call will not perform the action again. </p> <p> Note that request tokens are valid only for a few minutes. You cannot use request tokens to dedupe requests spanning hours or days. </p>',
    )
    rowsToUpdate: List[UpdateRowData] = Field(
        ...,
        description='<p> The list of rows to update in the table. Each item in this list needs to contain the row id to update along with the map of column id to cell values for each column in that row that needs to be updated. You need to specify at least one row in this list, and for each row, you need to specify at least one column to update. </p> <p> Note that if one of the row or column ids in the request does not exist in the table, then the request fails and no updates are made to the table. </p>',
        max_length=100,
        min_length=1,
    )


class WorkbooksWorkbookIdTablesTableIdRowsBatchupsertPostRequest(BaseModel):
    model_config = ConfigDict(
        regex_engine="python-re",
    )
    clientRequestToken: Optional[
        constr(pattern=r'^(?!\s*$).+', min_length=32, max_length=64)
    ] = Field(
        None,
        description='<p> The request token for performing the update action. Request tokens help to identify duplicate requests. If a call times out or fails due to a transient error like a failed network connection, you can retry the call with the same request token. The service ensures that if the first call using that request token is successfully performed, the second call will not perform the action again. </p> <p> Note that request tokens are valid only for a few minutes. You cannot use request tokens to dedupe requests spanning hours or days. </p>',
    )
    rowsToUpsert: List[UpsertRowData] = Field(
        ...,
        description='<p> The list of rows to upsert in the table. Each item in this list needs to have a batch item id to uniquely identify the element in the request, a filter expression to find the rows to update for that element and the cell values to set for each column in the upserted rows. You need to specify at least one item in this list. </p> <p> Note that if one of the filter formulas in the request fails to evaluate because of an error or one of the column ids in any of the rows does not exist in the table, then the request fails and no updates are made to the table. </p>',
    )


class BatchCreateTableRowsResult(BaseModel):
    createdRows: CreatedRowsMap
    failedBatchItems: Optional[FailedBatchItems] = None
    workbookCursor: WorkbookCursor


class BatchUpdateTableRowsRequest(BaseModel):
    clientRequestToken: Optional[ClientRequestToken] = None
    rowsToUpdate: UpdateRowDataList


class BatchUpsertTableRowsRequest(BaseModel):
    clientRequestToken: Optional[ClientRequestToken] = None
    rowsToUpsert: UpsertRowDataList


class CreateRowData(BaseModel):
    batchItemId: BatchItemId
    cellsToCreate: RowDataInput


class CreateRowDataList(RootModel[List[CreateRowData]]):
    root: List[CreateRowData] = Field(..., max_length=100, min_length=1)


class DestinationOptions(BaseModel):
    columnMap: Optional[ImportColumnMap] = None


class GetScreenDataResult(BaseModel):
    nextToken: Optional[PaginationToken] = None
    results: ResultSetMap
    workbookCursor: WorkbookCursor


class ImportDataSource(BaseModel):
    dataSourceConfig: ImportDataSourceConfig


class ImportOptions(BaseModel):
    delimitedTextOptions: Optional[DelimitedTextImportOptions] = None
    destinationOptions: Optional[DestinationOptions] = None


class ListTableColumnsResult(BaseModel):
    nextToken: Optional[PaginationToken] = None
    tableColumns: TableColumns
    workbookCursor: Optional[WorkbookCursor] = None


class ListTableRowsResult(BaseModel):
    columnIds: ResourceIds
    nextToken: Optional[PaginationToken] = None
    rowIdsNotFound: Optional[RowIdList] = None
    rows: TableRows
    workbookCursor: WorkbookCursor


class ListTablesResult(BaseModel):
    nextToken: Optional[PaginationToken] = None
    tables: Tables
    workbookCursor: Optional[WorkbookCursor] = None


class QueryTableRowsResult(BaseModel):
    columnIds: ResourceIds
    nextToken: Optional[PaginationToken] = None
    rows: TableRows
    workbookCursor: WorkbookCursor


class StartTableDataImportJobRequest(BaseModel):
    clientRequestToken: ClientRequestToken
    dataFormat: ImportSourceDataFormat
    dataSource: ImportDataSource
    importOptions: ImportOptions


class TableDataImportJobMetadata(BaseModel):
    dataSource: ImportDataSource
    importOptions: ImportOptions
    submitTime: TimestampInMillis
    submitter: ImportJobSubmitter


class WorkbooksWorkbookIdTablesTableIdImportPostRequest(BaseModel):
    model_config = ConfigDict(
        regex_engine="python-re",
    )
    clientRequestToken: constr(pattern=r'^(?!\s*$).+', min_length=32, max_length=64) = (
        Field(
            ...,
            description='<p> The request token for performing the update action. Request tokens help to identify duplicate requests. If a call times out or fails due to a transient error like a failed network connection, you can retry the call with the same request token. The service ensures that if the first call using that request token is successfully performed, the second call will not perform the action again. </p> <p> Note that request tokens are valid only for a few minutes. You cannot use request tokens to dedupe requests spanning hours or days. </p>',
        )
    )
    dataFormat: DataFormat = Field(
        ...,
        description=' The format of the data that is being imported. Currently the only option supported is "DELIMITED_TEXT". ',
    )
    dataSource: DataSource = Field(
        ...,
        description='An object that has details about the source of the data that was submitted for import.',
    )
    importOptions: ImportOptions = Field(
        ...,
        description='An object that contains the options specified by the sumitter of the import request.',
    )


class WorkbooksWorkbookIdTablesTableIdRowsBatchcreatePostRequest(BaseModel):
    model_config = ConfigDict(
        regex_engine="python-re",
    )
    clientRequestToken: Optional[
        constr(pattern=r'^(?!\s*$).+', min_length=32, max_length=64)
    ] = Field(
        None,
        description='<p> The request token for performing the batch create operation. Request tokens help to identify duplicate requests. If a call times out or fails due to a transient error like a failed network connection, you can retry the call with the same request token. The service ensures that if the first call using that request token is successfully performed, the second call will not perform the operation again. </p> <p> Note that request tokens are valid only for a few minutes. You cannot use request tokens to dedupe requests spanning hours or days. </p>',
    )
    rowsToCreate: List[CreateRowData] = Field(
        ...,
        description='<p> The list of rows to create at the end of the table. Each item in this list needs to have a batch item id to uniquely identify the element in the request and the cells to create for that row. You need to specify at least one item in this list. </p> <p> Note that if one of the column ids in any of the rows in the request does not exist in the table, then the request fails and no updates are made to the table. </p>',
        max_length=100,
        min_length=1,
    )


class BatchCreateTableRowsRequest(BaseModel):
    clientRequestToken: Optional[ClientRequestToken] = None
    rowsToCreate: CreateRowDataList


class DescribeTableDataImportJobResult(BaseModel):
    errorCode: Optional[ErrorCode] = None
    jobMetadata: TableDataImportJobMetadata
    jobStatus: TableDataImportJobStatus
    message: TableDataImportJobMessage
